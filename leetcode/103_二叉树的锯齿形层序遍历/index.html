<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">

    
<link rel="stylesheet" href="/blog-theme/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="/blog-theme/css/global.css">

    
<link rel="stylesheet" href="/blog-theme/css/article.css">

    
    
<script src="/blog-theme/bootstrap/js/bootstrap.bundle.min.js"></script>


    <title>
        I&#39;m prime
    </title>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="bg-dark">
    <header>
    <nav class="navbar navbar-expand navbar-expand-lg navbar-dark sticky-top shadow">
        <div class="container-fluid">
            <a class="navbar-brand" href="/blog-theme/">

                

            I&#39;m prime
            </a>

            <div class="collapse navbar-collapse justify-content-end" id="navbarNavDropdown">
                <ul class="navbar-nav">

                    

                        <li class="nav-item">
                            <a class="nav-link " aria-current="page"
                                href="/blog-theme/">
                                主页
                            </a>
                        </li>

                    

                        <li class="nav-item">
                            <a class="nav-link " aria-current="page"
                                href="/blog-theme/archives/">
                                归档
                            </a>
                        </li>

                    

                </ul>
            </div>
        </div>
    </nav>
</header>
    <div class="container-fluid mt-md-5">
    <div class="row">
        <div class="col"></div>
        <div class="col-12 col-sm-10 col-md-8 col-lg-7 col-xl-5 shadow-lg">
            <div class="container-fluid mt-5 text-center">
                <h1 class="text-white">
                    103. 二叉树的锯齿形层序遍历(每日一题)
                </h1>
                <p class="mt-2 text-secondary">
                    2020.12.22
                </p>
            </div>

            <article class="container-fluid text-white">
                <h2 id="leetcode-笔记"><a href="#leetcode-笔记" class="headerlink" title="leetcode 笔记"></a><a href="https://lzyprime.github.io/leetcode/leetcode">leetcode 笔记</a></h2><hr>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回锯齿形层序遍历如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal">https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>二叉树的层次遍历。</p>
<p>至于从前往后还是从后往前读，无非是个下标的问题。开一个和当前层等长的数组，如果从后往前读则下标倒序，把当前层的val插入到数组里。</p>
<ul>
<li><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">bool</span> reverse = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                root = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                tmp[reverse ? len - i - <span class="number">1</span> : i] = root -&gt; val;</span><br><span class="line">                <span class="keyword">if</span>(root -&gt; left != <span class="literal">nullptr</span>) q.<span class="built_in">push</span>(root -&gt; left);</span><br><span class="line">                <span class="keyword">if</span>(root -&gt; right != <span class="literal">nullptr</span>) q.<span class="built_in">push</span>(root -&gt; right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">move</span>(tmp));</span><br><span class="line">            reverse = !reverse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数式语言里, 利用<code>flatMap</code>可以很容易的拿到下一层节点组成的集合, <code>map</code>得到当前层节点<code>val</code>的集合。</p>
<ul>
<li><h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3></li>
</ul>
<p>尾递归函数 <code>tailrec fun zigzagLevelOrder</code>:</p>
<p><code>ans: List&lt;List&lt;Int&gt;&gt;</code> : 当前的累计结果</p>
<p><code>list: List&lt;TreeNode&gt;</code> : 当前层节点。 </p>
<p><code>reverse: Boolean</code> : 是否要倒序</p>
<p>如果当前层没有节点, 说明到底了, 返回<code>ans</code>; 否则， <code>ans</code> + 当前层节点<code>val</code>的集合 作为新的累计结果， <code>list.flatMap&#123; it -&gt; listOfNotNull(it.left, it.right) &#125;</code> 得到下一层非空节点的集合， 开始调用下一层</p>
<p>所以可以一行， 一刀流。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">zigzagLevelOrder</span><span class="params">(ans: <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Int</span>&gt;&gt;, list: <span class="type">List</span>&lt;<span class="type">TreeNode</span>&gt;, reverse: <span class="type">Boolean</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; = <span class="keyword">if</span> (list.isEmpty()) ans <span class="keyword">else</span> zigzagLevelOrder(ans + listOf(list.map &#123; it.`<span class="keyword">val</span>` &#125;.let &#123; <span class="keyword">if</span> (reverse) it.asReversed() <span class="keyword">else</span> it &#125;), list.flatMap &#123; listOfNotNull(it.left, it.right) &#125;, !reverse)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">zigzagLevelOrder</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        root ?: <span class="keyword">return</span> emptyList()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">zigzagLevelOrder</span><span class="params">(ans: <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Int</span>&gt;&gt;, list: <span class="type">List</span>&lt;<span class="type">TreeNode</span>&gt;, reverse: <span class="type">Boolean</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; =</span><br><span class="line">            <span class="keyword">if</span> (list.isEmpty()) ans</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                zigzagLevelOrder(</span><br><span class="line">                    ans + listOf(list.map &#123; it.`<span class="keyword">val</span>` &#125;.let &#123; <span class="keyword">if</span> (reverse) it.asReversed() <span class="keyword">else</span> it &#125;),</span><br><span class="line">                    list.flatMap &#123; listOfNotNull(it.left, it.right) &#125;,</span><br><span class="line">                    !reverse</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> zigzagLevelOrder(emptyList(), listOf(root), <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h3></li>
</ul>
<p>一刀流</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@tailrec</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span></span>(ans: <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]], list: <span class="type">List</span>[<span class="type">TreeNode</span>], reverse: <span class="type">Boolean</span>): <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] = <span class="keyword">if</span> (list.isEmpty) ans <span class="keyword">else</span> zigzagLevelOrder(ans ::: <span class="type">List</span>(<span class="keyword">if</span> (reverse) list.map(_.value).reverse <span class="keyword">else</span> list.map(_.value)) ::: <span class="type">Nil</span>, list flatMap (it =&gt; it.left :: it.right :: <span class="type">Nil</span>) filter (_ != <span class="literal">null</span>), !reverse)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * class TreeNode(var _value: Int) &#123;</span></span><br><span class="line"><span class="comment"> *   var value: Int = _value</span></span><br><span class="line"><span class="comment"> *   var left: TreeNode = null</span></span><br><span class="line"><span class="comment"> *   var right: TreeNode = null</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.annotation.tailrec</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span></span>(root: <span class="type">TreeNode</span>): <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@tailrec</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span></span>(ans: <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]], list: <span class="type">List</span>[<span class="type">TreeNode</span>], reverse: <span class="type">Boolean</span>): <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] =</span><br><span class="line">      <span class="keyword">if</span> (list.isEmpty) ans</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        zigzagLevelOrder(</span><br><span class="line">          ans ::: <span class="type">List</span>(<span class="keyword">if</span> (reverse) list.map(_.value).reverse <span class="keyword">else</span> list.map(_.value)) ::: <span class="type">Nil</span>,</span><br><span class="line">          list flatMap (it =&gt; it.left :: it.right :: <span class="type">Nil</span>) filter (_ != <span class="literal">null</span>),</span><br><span class="line">          !reverse</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    zigzagLevelOrder(<span class="type">Nil</span>, <span class="type">List</span>(root), reverse = <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>rust</li>
</ul>
<p>这种数据结构题用 <code>Rust</code> 很不地道。尤其是一刀流，会比普通写法还长，函数栈的原因要多耗点内存。算法复杂度相同的话，两种写法耗时不会有差距</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一刀流 花括号不能省，导致很长</span></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">zigzag_level_order</span></span>(root: <span class="built_in">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = root &#123;</span><br><span class="line">            <span class="function"><span class="keyword">fn</span> <span class="title">zigzag_level_order</span></span>(</span><br><span class="line">                <span class="keyword">mut</span> ans: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt;,</span><br><span class="line">                cur: <span class="built_in">Vec</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span><br><span class="line">                reverse: <span class="built_in">bool</span>,</span><br><span class="line">            ) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> cur.is_empty() &#123;</span><br><span class="line">                    ans</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    zigzag_level_order(</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">let</span> tmp = cur.iter().map(|i| i.borrow().val);</span><br><span class="line">                            ans.push(<span class="keyword">if</span> reverse &#123;</span><br><span class="line">                                tmp.rev().collect()</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                tmp.collect()</span><br><span class="line">                            &#125;);</span><br><span class="line">                            ans</span><br><span class="line">                        &#125;,</span><br><span class="line">                        cur.iter().fold(<span class="built_in">vec!</span>[], |<span class="keyword">mut</span> acc, i| &#123;</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="keyword">ref</span> left) = i.borrow().left &#123;</span><br><span class="line">                                acc.push(left.clone())</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="keyword">ref</span> right) = i.borrow().right &#123;</span><br><span class="line">                                acc.push(right.clone())</span><br><span class="line">                            &#125;</span><br><span class="line">                            acc</span><br><span class="line">                        &#125;),</span><br><span class="line">                        !reverse,</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            zigzag_level_order(<span class="built_in">vec!</span>[], <span class="built_in">vec!</span>[i], <span class="literal">false</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">vec!</span>[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            </article>
        </div>

        <div class="col"></div>
    </div>
</div>
    <footer class="h-25"> footer </footer>
</body>

</html>