<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">

    
<link rel="stylesheet" href="/blog-theme/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="/blog-theme/css/global.css">

    
<link rel="stylesheet" href="/blog-theme/css/article.css">

    
    
<script src="/blog-theme/bootstrap/js/bootstrap.bundle.min.js"></script>


    <title>
        I&#39;m prime
    </title>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="bg-dark">
    <header>
    <nav class="navbar navbar-expand navbar-expand-lg navbar-dark sticky-top shadow">
        <div class="container-fluid">
            <a class="navbar-brand" href="/blog-theme/">

                

            I&#39;m prime
            </a>

            <div class="collapse navbar-collapse justify-content-end" id="navbarNavDropdown">
                <ul class="navbar-nav">

                    

                        <li class="nav-item">
                            <a class="nav-link " aria-current="page"
                                href="/blog-theme/">
                                主页
                            </a>
                        </li>

                    

                        <li class="nav-item">
                            <a class="nav-link " aria-current="page"
                                href="/blog-theme/archives/">
                                归档
                            </a>
                        </li>

                    

                </ul>
            </div>
        </div>
    </nav>
</header>
    <div class="container-fluid mt-md-5">
    <div class="row">
        <div class="col"></div>
        <div class="col-12 col-sm-10 col-md-8 col-lg-7 col-xl-5 shadow-lg">
            <div class="container-fluid mt-5 text-center">
                <h1 class="text-white">
                    721. 账户合并(每日一题)
                </h1>
                <p class="mt-2 text-secondary">
                    2021.01.18
                </p>
            </div>

            <article class="container-fluid text-white">
                <h2 id="leetcode-笔记"><a href="#leetcode-笔记" class="headerlink" title="leetcode 笔记"></a><a href="https://lzyprime.github.io/leetcode/leetcode">leetcode 笔记</a></h2><hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。</p>
<p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p>
<p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。</p>
<p> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">accounts = [[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</span><br><span class="line">输出：</span><br><span class="line">[[&quot;John&quot;, &#x27;john00@mail.com&#x27;, &#x27;john_newyork@mail.com&#x27;, &#x27;johnsmith@mail.com&#x27;],  [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</span><br><span class="line">解释：</span><br><span class="line">第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 &quot;johnsmith@mail.com&quot;。 </span><br><span class="line">第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。</span><br><span class="line">可以以任何顺序返回这些列表，例如答案 [[&#x27;Mary&#x27;，&#x27;mary@mail.com&#x27;]，[&#x27;John&#x27;，&#x27;johnnybravo@mail.com&#x27;]，</span><br><span class="line">[&#x27;John&#x27;，&#x27;john00@mail.com&#x27;，&#x27;john_newyork@mail.com&#x27;，&#x27;johnsmith@mail.com&#x27;]] 也是正确的。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">accounts的长度将在[1，1000]的范围内。</span><br><span class="line">accounts[i]的长度将在[1，10]的范围内。</span><br><span class="line">accounts[i][j]的长度将在[1，30]的范围内。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/accounts-merge">https://leetcode-cn.com/problems/accounts-merge</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  </p>
</blockquote>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>又是并查集。 </p>
<p>每个邮箱给一个独一无二的index, 错开原有的[0, accounts.size())；用户用原有的数组下标做index。</p>
<p>每个邮箱找父节点，如果为自己，则父节点指定为当前用户index， 如果已属于其他用户，则当前用户的父节点指定为其他用户，从而实现合并。</p>
<p><code>kotlin, scala</code>可以用<code>Map&lt;Any, Any&gt;</code>维护父节点关系，这样可以省掉邮箱<code>String</code>到<code>Int</code>的映射关系。</p>
<ul>
<li><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">find_parent</span><span class="params">(unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; par, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!par.<span class="built_in">count</span>(x)) <span class="keyword">return</span> par[x] = x;</span><br><span class="line">    <span class="keyword">return</span> par[x] = par[x] == x ? x : <span class="built_in">find_parent</span>(par, par[x]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; <span class="built_in">accountsMerge</span>(vector&lt;vector&lt;string&gt;&gt;&amp; accounts) &#123;</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; s_index;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; par;</span><br><span class="line">    <span class="keyword">auto</span> get_index = [&amp;](<span class="keyword">const</span> string&amp; x) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> s_index.<span class="built_in">count</span>(x) ? s_index[x] : (s_index[x] = -s_index.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; accounts.<span class="built_in">size</span>(); i++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, pre = i; j &lt; accounts[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> si = <span class="built_in">get_index</span>(accounts[i][j]);</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">find_parent</span>(par, si);</span><br><span class="line">        <span class="keyword">if</span> (p == si)</span><br><span class="line">          par[si] = pre;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            par[pre] = p;</span><br><span class="line">            pre = p;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, set&lt;string&gt;&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : s_index) mp[<span class="built_in">find_parent</span>(par, i.second)].<span class="built_in">insert</span>(i.first);</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : mp) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(&#123;accounts[i.first][<span class="number">0</span>]&#125;);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; j : i.second) res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3></li>
</ul>
<p>一刀流</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">accountsMerge</span><span class="params">(accounts: <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt;)</span></span>: List&lt;List&lt;String&gt;&gt; = accounts.foldIndexed(mutableMapOf&lt;Any, Any&gt;()) &#123; index, par, list -&gt; (<span class="number">1.</span>.list.lastIndex).forEach &#123; i -&gt; <span class="keyword">when</span> (<span class="keyword">val</span> p = par.findParent(list[i])) &#123;list[i] -&gt; par[p] = par.findParent(index);<span class="keyword">else</span> -&gt; par[par.findParent(index)] = p &#125; &#125;;par &#125;.let &#123; par -&gt; par.entries.fold(mutableMapOf&lt;<span class="built_in">Int</span>, MutableList&lt;String&gt;&gt;()) &#123; acc, (k, v) -&gt; <span class="keyword">if</span> (k <span class="keyword">is</span> String) acc.getOrPut(par.findParent(v) <span class="keyword">as</span> <span class="built_in">Int</span>) &#123; mutableListOf() &#125; += k;acc &#125;.entries.fold(mutableListOf()) &#123; acc, (k, v) -&gt; acc.apply &#123; add(listOf(accounts[k].first()) + v.sorted()) &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> MutableMap<span class="type">&lt;Any, Any&gt;</span>.<span class="title">findParent</span><span class="params">(x: <span class="type">Any</span>)</span></span>: Any =</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getOrPut(x) &#123; x &#125; != x) findParent(<span class="keyword">this</span>[x]!!) <span class="keyword">else</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">accountsMerge</span><span class="params">(accounts: <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt;)</span></span>: List&lt;List&lt;String&gt;&gt; =</span><br><span class="line">        accounts.foldIndexed(mutableMapOf&lt;Any, Any&gt;()) &#123; index, par, list -&gt;</span><br><span class="line">            (<span class="number">1.</span>.list.lastIndex).forEach &#123; i -&gt;</span><br><span class="line">                <span class="keyword">when</span> (<span class="keyword">val</span> p = par.findParent(list[i])) &#123;</span><br><span class="line">                    list[i] -&gt; par[p] = par.findParent(index)</span><br><span class="line">                    <span class="keyword">else</span> -&gt; par[par.findParent(index)] = p</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            par</span><br><span class="line">        &#125;.let &#123; par -&gt;</span><br><span class="line">            par.entries.fold(mutableMapOf&lt;<span class="built_in">Int</span>, MutableList&lt;String&gt;&gt;()) &#123; acc, (k, v) -&gt;</span><br><span class="line">                <span class="keyword">if</span> (k <span class="keyword">is</span> String) acc.getOrPut(par.findParent(v) <span class="keyword">as</span> <span class="built_in">Int</span>) &#123; mutableListOf() &#125; += k</span><br><span class="line">                acc</span><br><span class="line">            &#125;.entries.fold(mutableListOf()) &#123; acc, (k, v) -&gt;</span><br><span class="line">                acc.apply &#123; add(listOf(accounts[k].first()) + v.sorted()) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h3></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.annotation.tailrec</span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="meta">@tailrec</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">findParent</span></span>(par: mutable.<span class="type">Map</span>[<span class="type">Any</span>, <span class="type">Any</span>], x: <span class="type">Any</span>): <span class="type">Any</span> = <span class="keyword">if</span> (par.getOrElseUpdate(x, x) != x) findParent(par, par(x)) <span class="keyword">else</span> x</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span></span>(accounts: <span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]]): <span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]] = &#123;</span><br><span class="line">    <span class="keyword">val</span> par = accounts.indices.foldLeft(mutable.<span class="type">Map</span>[<span class="type">Any</span>, <span class="type">Any</span>]())((par, i) =&gt; &#123;</span><br><span class="line">      (<span class="number">1</span> until accounts(i).length).foreach(j =&gt;</span><br><span class="line">        <span class="keyword">if</span> (findParent(par, accounts(i)(j)) == accounts(i)(j))</span><br><span class="line">          par(accounts(i)(j)) = findParent(par, i)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          par(findParent(par, i)) = findParent(par, accounts(i)(j)))</span><br><span class="line">      par</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    par.foldLeft(mutable.<span class="type">Map</span>[<span class="type">Int</span>, mutable.<span class="type">ListBuffer</span>[<span class="type">String</span>]]())((acc, i) =&gt; &#123;</span><br><span class="line">      i._1 <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> str: <span class="type">String</span> =&gt; acc.getOrElseUpdate(findParent(par, i._2).asInstanceOf[<span class="type">Int</span>], mutable.<span class="type">ListBuffer</span>()).addOne(str)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="type">None</span></span><br><span class="line">      &#125;</span><br><span class="line">      acc</span><br><span class="line">    &#125;).foldLeft(mutable.<span class="type">ListBuffer</span>[<span class="type">List</span>[<span class="type">String</span>]]())((acc, i) =&gt; acc.addOne(accounts(i._1).head :: i._2.sorted.toList)).toList</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h3></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">accounts_merge</span></span>(accounts: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">find_parent</span></span>(par: &amp;<span class="keyword">mut</span> HashMap&lt;<span class="built_in">i32</span>, <span class="built_in">i32</span>&gt;, x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> par.entry(x).or_insert(x).clone() != x &#123;</span><br><span class="line">                <span class="keyword">let</span> p = find_parent(par, par[&amp;x]);</span><br><span class="line">                par.insert(x, p);</span><br><span class="line">                p</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> str2i: HashMap&lt;&amp;<span class="built_in">String</span>, <span class="built_in">i32</span>&gt; = HashMap::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> par = accounts</span><br><span class="line">            .iter()</span><br><span class="line">            .enumerate()</span><br><span class="line">            .fold(HashMap::new(), |<span class="keyword">mut</span> par, (i, list)| &#123;</span><br><span class="line">                (<span class="number">1</span>..list.len()).for_each(|j| &#123;</span><br><span class="line">                    <span class="keyword">let</span> len = str2i.len() <span class="keyword">as</span> <span class="built_in">i32</span>;</span><br><span class="line">                    <span class="keyword">let</span> si = *str2i.entry(&amp;list[j]).or_insert(-len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">let</span> p = find_parent(&amp;<span class="keyword">mut</span> par, si);</span><br><span class="line">                    <span class="keyword">if</span> p == si &#123;</span><br><span class="line">                        <span class="keyword">let</span> p = find_parent(&amp;<span class="keyword">mut</span> par, i <span class="keyword">as</span> <span class="built_in">i32</span>);</span><br><span class="line">                        par.insert(si, p);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> p2 = find_parent(&amp;<span class="keyword">mut</span> par, i <span class="keyword">as</span> <span class="built_in">i32</span>);</span><br><span class="line">                        par.insert(p, p2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                par</span><br><span class="line">            &#125;);</span><br><span class="line">        str2i</span><br><span class="line">            .drain()</span><br><span class="line">            .fold(HashMap::new(), |<span class="keyword">mut</span> mp, (k, v)| &#123;</span><br><span class="line">                mp.entry(find_parent(&amp;<span class="keyword">mut</span> par, v))</span><br><span class="line">                    .or_insert(<span class="built_in">vec!</span>[])</span><br><span class="line">                    .push(k.clone());</span><br><span class="line">                mp</span><br><span class="line">            &#125;)</span><br><span class="line">            .drain()</span><br><span class="line">            .fold(<span class="built_in">vec!</span>[], |<span class="keyword">mut</span> acc, (i, <span class="keyword">mut</span> l)| &#123;</span><br><span class="line">                l.sort();</span><br><span class="line">                l.insert(<span class="number">0</span>, accounts[i <span class="keyword">as</span> <span class="built_in">usize</span>][<span class="number">0</span>].clone());</span><br><span class="line">                acc.push(l);</span><br><span class="line">                acc</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
            </article>
        </div>

        <div class="col"></div>
    </div>
</div>
    <footer class="h-25"> footer </footer>
</body>

</html>